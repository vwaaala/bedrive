{
  "version": 3,
  "sources": ["../../@react-aria/focus/dist/packages/@react-aria/focus/src/index.ts", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/FocusScope.tsx", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/focusSafely.ts", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/isElementVisible.ts", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/FocusRing.tsx", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/useFocusRing.ts", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/useFocusable.tsx", "../../@react-aria/focus/dist/packages/@react-aria/focus/src/useHasTabbableChild.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {FocusScope, useFocusManager, getFocusableTreeWalker, createFocusManager, isElementInChildOfActiveScope} from './FocusScope';\nexport {FocusRing} from './FocusRing';\nexport {FocusableProvider, useFocusable} from './useFocusable';\nexport {useFocusRing} from './useFocusRing';\nexport {focusSafely} from './focusSafely';\nexport {useHasTabbableChild} from './useHasTabbableChild';\n\nexport type {FocusScopeProps, FocusManager, FocusManagerOptions} from './FocusScope';\nexport type {FocusRingProps} from './FocusRing';\nexport type {FocusableAria, FocusableOptions, FocusableProviderProps} from './useFocusable';\nexport type {AriaFocusRingProps, FocusRingAria} from './useFocusRing';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n    /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[]> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>();\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>();\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef)) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (ownerDocument.body.contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  focusElement(nextNode as FocusableElement);\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n      isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef)) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(ownerDocument.body, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n           // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n           // then move focus to the body.\n           // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          isElementInScope(ownerDocument.activeElement, scopeRef.current)\n          || (ownerDocument.activeElement === ownerDocument.body && shouldRestoreFocus(scopeRef))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === ownerDocument.body) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                focusElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                focusFirstInScope(treeNode.scopeRef.current, true);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = getOwnerDocument(root).createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getOwnerDocument(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n", "/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getOwnerWindow} from '@react-aria/utils';\n\nfunction isStyleVisible(element: Element) {\n  const windowObject = getOwnerWindow(element);\n  if (!(element instanceof windowObject.HTMLElement) && !(element instanceof windowObject.SVGElement)) {\n    return false;\n  }\n\n  let {display, visibility} = element.style;\n\n  let isVisible = (\n    display !== 'none' &&\n    visibility !== 'hidden' &&\n    visibility !== 'collapse'\n  );\n\n  if (isVisible) {\n    const {getComputedStyle} = element.ownerDocument.defaultView as unknown as Window;\n    let {display: computedDisplay, visibility: computedVisibility} = getComputedStyle(element);\n\n    isVisible = (\n      computedDisplay !== 'none' &&\n      computedVisibility !== 'hidden' &&\n      computedVisibility !== 'collapse'\n    );\n  }\n\n  return isVisible;\n}\n\nfunction isAttributeVisible(element: Element, childElement?: Element) {\n  return (\n    !element.hasAttribute('hidden') &&\n    (element.nodeName === 'DETAILS' &&\n      childElement &&\n      childElement.nodeName !== 'SUMMARY'\n      ? element.hasAttribute('open')\n      : true)\n  );\n}\n\n/**\n * Adapted from https://github.com/testing-library/jest-dom and\n * https://github.com/vuejs/vue-test-utils-next/.\n * Licensed under the MIT License.\n * @param element - Element to evaluate for display or visibility.\n */\nexport function isElementVisible(element: Element, childElement?: Element) {\n  return (\n    element.nodeName !== '#comment' &&\n    isStyleVisible(element) &&\n    isAttributeVisible(element, childElement) &&\n    (!element.parentElement || isElementVisible(element.parentElement, element))\n  );\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport clsx from 'clsx';\nimport {mergeProps} from '@react-aria/utils';\nimport React, {ReactElement} from 'react';\nimport {useFocusRing} from './useFocusRing';\n\nexport interface FocusRingProps {\n  /** Child element to apply CSS classes to. */\n  children: ReactElement,\n  /** CSS class to apply when the element is focused. */\n  focusClass?: string,\n  /** CSS class to apply when the element has keyboard focus. */\n  focusRingClass?: string,\n  /**\n   * Whether to show the focus ring when something\n   * inside the container element has focus (true), or\n   * only if the container itself has focus (false).\n   * @default false\n   */\n  within?: boolean,\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\n/**\n * A utility component that applies a CSS class when an element has keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function FocusRing(props: FocusRingProps) {\n  let {children, focusClass, focusRingClass} = props;\n  let {isFocused, isFocusVisible, focusProps} = useFocusRing(props);\n  let child = React.Children.only(children);\n\n  return React.cloneElement(child, mergeProps(child.props, {\n    ...focusProps,\n    className: clsx({\n      [focusClass || '']: isFocused,\n      [focusRingClass || '']: isFocusVisible\n    })\n  }));\n}\n", "import {DOMAttributes} from '@react-types/shared';\nimport {isFocusVisible, useFocus, useFocusVisibleListener, useFocusWithin} from '@react-aria/interactions';\nimport {useCallback, useRef, useState} from 'react';\n\nexport interface AriaFocusRingProps {\n  /**\n   * Whether to show the focus ring when something\n   * inside the container element has focus (true), or\n   * only if the container itself has focus (false).\n   * @default 'false'\n   */\n  within?: boolean,\n\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusRingAria {\n  /** Whether the element is currently focused. */\n  isFocused: boolean,\n\n  /** Whether keyboard focus should be visible. */\n  isFocusVisible: boolean,\n\n  /** Props to apply to the container element with the focus ring. */\n  focusProps: DOMAttributes\n}\n\n/**\n * Determines whether a focus ring should be shown to indicate keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function useFocusRing(props: AriaFocusRingProps = {}): FocusRingAria {\n  let {\n    autoFocus = false,\n    isTextInput,\n    within\n  } = props;\n  let state = useRef({\n    isFocused: false,\n    isFocusVisible: autoFocus || isFocusVisible()\n  });\n  let [isFocused, setFocused] = useState(false);\n  let [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible);\n\n  let updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n\n  let onFocusChange = useCallback(isFocused => {\n    state.current.isFocused = isFocused;\n    setFocused(isFocused);\n    updateState();\n  }, [updateState]);\n\n  useFocusVisibleListener((isFocusVisible) => {\n    state.current.isFocusVisible = isFocusVisible;\n    updateState();\n  }, [], {isTextInput});\n\n  let {focusProps} = useFocus({\n    isDisabled: within,\n    onFocusChange\n  });\n\n  let {focusWithinProps} = useFocusWithin({\n    isDisabled: !within,\n    onFocusWithinChange: onFocusChange\n  });\n\n  return {\n    isFocused,\n    isFocusVisible: isFocusVisibleState,\n    focusProps: within ? focusWithinProps : focusProps\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableDOMProps, FocusableElement, FocusableProps} from '@react-types/shared';\nimport {focusSafely} from './';\nimport {mergeProps, useObjectRef, useSyncRef} from '@react-aria/utils';\nimport React, {ForwardedRef, MutableRefObject, ReactNode, RefObject, useContext, useEffect, useRef} from 'react';\nimport {useFocus, useKeyboard} from '@react-aria/interactions';\n\nexport interface FocusableOptions extends FocusableProps, FocusableDOMProps {\n  /** Whether focus should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface FocusableProviderProps extends DOMAttributes {\n  /** The child element to provide DOM props to. */\n  children?: ReactNode\n}\n\ninterface FocusableContextValue extends FocusableProviderProps {\n  ref?: MutableRefObject<FocusableElement | null>\n}\n\nlet FocusableContext = React.createContext<FocusableContextValue | null>(null);\n\nfunction useFocusableContext(ref: RefObject<FocusableElement>): FocusableContextValue {\n  let context = useContext(FocusableContext) || {};\n  useSyncRef(context, ref);\n\n  // eslint-disable-next-line\n  let {ref: _, ...otherProps} = context;\n  return otherProps;\n}\n\n/**\n * Provides DOM props to the nearest focusable child.\n */\nfunction FocusableProvider(props: FocusableProviderProps, ref: ForwardedRef<FocusableElement>) {\n  let {children, ...otherProps} = props;\n  let objRef = useObjectRef(ref);\n  let context = {\n    ...otherProps,\n    ref: objRef\n  };\n\n  return (\n    <FocusableContext.Provider value={context}>\n      {children}\n    </FocusableContext.Provider>\n  );\n}\n\nlet _FocusableProvider = React.forwardRef(FocusableProvider);\nexport {_FocusableProvider as FocusableProvider};\n\nexport interface FocusableAria {\n  /** Props for the focusable element. */\n  focusableProps: DOMAttributes\n}\n\n/**\n * Used to make an element focusable and capable of auto focus.\n */\nexport function useFocusable(props: FocusableOptions, domRef: RefObject<FocusableElement>): FocusableAria {\n  let {focusProps} = useFocus(props);\n  let {keyboardProps} = useKeyboard(props);\n  let interactions = mergeProps(focusProps, keyboardProps);\n  let domProps = useFocusableContext(domRef);\n  let interactionProps = props.isDisabled ? {} : domProps;\n  let autoFocusRef = useRef(props.autoFocus);\n\n  useEffect(() => {\n    if (autoFocusRef.current && domRef.current) {\n      focusSafely(domRef.current);\n    }\n    autoFocusRef.current = false;\n  }, [domRef]);\n\n  return {\n    focusableProps: mergeProps(\n      {\n        ...interactions,\n        tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n      },\n      interactionProps\n    )\n  };\n}\n", "/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFocusableTreeWalker} from './FocusScope';\nimport {RefObject, useState} from 'react';\nimport {useLayoutEffect} from '@react-aria/utils';\n\ninterface AriaHasTabbableChildOptions {\n  isDisabled?: boolean\n}\n\n// This was created for a special empty case of a component that can have child or\n// be empty, like Collection/Virtualizer/Table/ListView/etc. When these components\n// are empty they can have a message with a tabbable element, which is like them\n// being not empty, when it comes to focus and tab order.\n\n/**\n * Returns whether an element has a tabbable child, and updates as children change.\n * @private\n */\nexport function useHasTabbableChild(ref: RefObject<Element>, options?: AriaHasTabbableChildOptions): boolean {\n  let isDisabled = options?.isDisabled;\n  let [hasTabbableChild, setHasTabbableChild] = useState(false);\n\n  useLayoutEffect(() => {\n    if (ref?.current && !isDisabled) {\n      let update = () => {\n        if (ref.current) {\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          setHasTabbableChild(!!walker.nextNode());\n        }\n      };\n\n      update();\n\n      // Update when new elements are inserted, or the tabIndex/disabled attribute updates.\n      let observer = new MutationObserver(update);\n      observer.observe(ref.current, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n        attributeFilter: ['tabIndex', 'disabled']\n      });\n\n      return () => {\n        // Disconnect mutation observer when a React update occurs on the top-level component\n        // so we update synchronously after re-rendering. Otherwise React will emit act warnings\n        // in tests since mutation observers fire asynchronously. The mutation observer is necessary\n        // so we also update if a child component re-renders and adds/removes something tabbable.\n        observer.disconnect();\n      };\n    }\n  });\n\n  return isDisabled ? false : hasTabbableChild;\n}\n"],
  "mappings": "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",
  "names": ["$6nfFC$react", "$6nfFC$useRef", "$6nfFC$useContext", "$6nfFC$useMemo", "node", "$6nfFC$useEffect", "scope", "treeNode", "$6nfFC$useState", "$6nfFC$useCallback", "isFocused"]
}
