{
  "version": 3,
  "sources": ["../../is-retry-allowed/index.js", "../../axios-retry/es/index.mjs"],
  "sourcesContent": ["'use strict';\n\nconst denyList = new Set([\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED',\n\t'HOSTNAME_MISMATCH'\n]);\n\n// TODO: Use `error?.code` when targeting Node.js 14\nmodule.exports = error => !denyList.has(error && error.code);\n", "import isRetryAllowed from 'is-retry-allowed';\n\nexport const namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n\n  return (\n    !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    !CODE_EXCLUDE_LIST.includes(error.code) && // Prevents retrying timed out & cancelled requests\n    isRetryAllowed(error) // Prevents retrying unsafe errors\n  );\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return (\n    error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n  );\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * Set delayFactor 1000 for an exponential delay to occur on the order\n * of seconds\n * @param  {number} [retryNumber=0]\n * @param  {Error}  error - unused; for existing API of retryDelay callback\n * @param  {number} [delayFactor=100] milliseconds\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0, error, delayFactor = 100) {\n  const delay = Math.pow(2, retryNumber) * delayFactor;\n  const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/** @type {IAxiosRetryConfig} */\nexport const DEFAULT_OPTIONS = {\n  retries: 3,\n  retryCondition: isNetworkOrIdempotentRequestError,\n  retryDelay: noDelay,\n  shouldResetTimeout: false,\n  onRetry: () => {}\n};\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return { ...DEFAULT_OPTIONS, ...defaultOptions, ...config[namespace] };\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @param  {IAxiosRetryConfig} defaultOptions\n * @return {IAxiosRetryConfigExtended}\n */\nfunction getCurrentState(config, defaultOptions) {\n  const currentState = getRequestOptions(config, defaultOptions);\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Checks retryCondition if request can be retried. Handles it's returning value or Promise.\n * @param  {IAxiosRetryConfigExtended} currentState\n * @param  {Error} error\n * @return {Promise<boolean>}\n */\nasync function shouldRetry(currentState, error) {\n  const { retries, retryCondition } = currentState;\n  const shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);\n\n  // This could be a promise\n  if (typeof shouldRetryOrPromise === 'object') {\n    try {\n      const shouldRetryPromiseResult = await shouldRetryOrPromise;\n      // keep return true unless shouldRetryPromiseResult return false for compatibility\n      return shouldRetryPromiseResult !== false;\n    } catch (_err) {\n      return false;\n    }\n  }\n  return shouldRetryOrPromise;\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n * @param {Function} [defaultOptions.onRetry=()=>{}]\n *        A function to get notified when a retry occurs\n * @return {{ requestInterceptorId: number, responseInterceptorId: number }}\n *        The ids of the interceptors added to the request and to the response (so they can be ejected at a later time)\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  const requestInterceptorId = axios.interceptors.request.use((config) => {\n    const currentState = getCurrentState(config, defaultOptions);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  const responseInterceptorId = axios.interceptors.response.use(null, async (error) => {\n    const { config } = error;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    const currentState = getCurrentState(config, defaultOptions);\n\n    if (await shouldRetry(currentState, error)) {\n      currentState.retryCount += 1;\n      const { retryDelay, shouldResetTimeout, onRetry } = currentState;\n      const delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n          return Promise.reject(error);\n        }\n        config.timeout = timeout;\n      }\n\n      config.transformRequest = [(data) => data];\n\n      await onRetry(currentState.retryCount, error, config);\n\n      return new Promise((resolve) => setTimeout(() => resolve(axios(config)), delay));\n    }\n\n    return Promise.reject(error);\n  });\n\n  return { requestInterceptorId, responseInterceptorId };\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n"],
  "mappings": ";;;;;;AAAA;AAAA;AAAA;AAEA,QAAM,WAAW,oBAAI,IAAI;AAAA,MACxB;AAAA,MACA;AAAA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,CAAC;AAGD,WAAO,UAAU,WAAS,CAAC,SAAS,IAAI,SAAS,MAAM,IAAI;AAAA;AAAA;;;ACtC3D,8BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEpB,IAAMA,YAAY;AAMlB,SAASC,eAAeC,OAAO;AACpC,MAAMC,oBAAoB,CAAC,gBAAgB,cAAjB;AAE1B,SACE,CAACD,MAAME,YACPC,QAAQH,MAAMI,IAAP;EACP,CAACH,kBAAkBI,SAASL,MAAMI,IAAjC;MACDE,wBAAAA,SAAeN,KAAD;AAEjB;AAED,IAAMO,oBAAoB,CAAC,OAAO,QAAQ,SAAhB;AAC1B,IAAMC,0BAA0BD,kBAAkBE,OAAO,CAAC,OAAO,QAAR,CAAzB;AAMzB,SAASC,iBAAiBV,OAAO;AACtC,SACEA,MAAMI,SAAS,mBACd,CAACJ,MAAME,YAAaF,MAAME,SAASS,UAAU,OAAOX,MAAME,SAASS,UAAU;AAEjF;AAMM,SAASC,mBAAmBZ,OAAO;AACxC,MAAI,CAACA,MAAMa,QAAQ;AAEjB,WAAO;EACR;AAED,SAAOH,iBAAiBV,KAAD,KAAWO,kBAAkBO,QAAQd,MAAMa,OAAOE,MAAvC,MAAmD;AACtF;AAMM,SAASC,yBAAyBhB,OAAO;AAC9C,MAAI,CAACA,MAAMa,QAAQ;AAEjB,WAAO;EACR;AAED,SAAOH,iBAAiBV,KAAD,KAAWQ,wBAAwBM,QAAQd,MAAMa,OAAOE,MAA7C,MAAyD;AAC5F;AAMM,SAASE,kCAAkCjB,OAAO;AACvD,SAAOD,eAAeC,KAAD,KAAWgB,yBAAyBhB,KAAD;AACzD;AAKD,SAASkB,UAAU;AACjB,SAAO;AACR;AAUM,SAASC,mBAA4D;AAAA,MAA3CC,cAA2C,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAA7B;AAA6B,MAA1BpB,QAA0B,UAAA,SAAA,IAAA,UAAA,CAAA,IAAA;AAAA,MAAnBqB,cAAmB,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAL;AACrE,MAAMC,QAAQC,KAAKC,IAAI,GAAGJ,WAAZ,IAA2BC;AACzC,MAAMI,YAAYH,QAAQ,MAAMC,KAAKG,OAAL;AAChC,SAAOJ,QAAQG;AAChB;AAGM,IAAME,kBAAkB;EAC7BC,SAAS;EACTC,gBAAgBZ;EAChBa,YAAYZ;EACZa,oBAAoB;EACpBC,SAAS,MAAM;EAAE;AALY;AAc/B,SAASC,kBAAkBpB,QAAQqB,gBAAgB;AACjD,SAAA,cAAA,cAAA,cAAA,CAAA,GAAYP,eAAZ,GAAgCO,cAAhC,GAAmDrB,OAAOf,SAAD,CAAzD;AACD;AAQD,SAASqC,gBAAgBtB,QAAQqB,gBAAgB;AAC/C,MAAME,eAAeH,kBAAkBpB,QAAQqB,cAAT;AACtCE,eAAaC,aAAaD,aAAaC,cAAc;AACrDxB,SAAOf,SAAD,IAAcsC;AACpB,SAAOA;AACR;AAMD,SAASE,UAAUC,OAAO1B,QAAQ;AAChC,MAAI0B,MAAMC,SAASC,UAAU5B,OAAO4B,OAAO;AACzC,WAAO5B,OAAO4B;EACf;AACD,MAAIF,MAAMC,SAASE,cAAc7B,OAAO6B,WAAW;AACjD,WAAO7B,OAAO6B;EACf;AACD,MAAIH,MAAMC,SAASG,eAAe9B,OAAO8B,YAAY;AACnD,WAAO9B,OAAO8B;EACf;AACF;SAQcC,YAAAA,IAAAA,KAAAA;;;;mCAAf,WAA2BR,cAAcpC,OAAO;AAC9C,QAAM;MAAE4B;MAASC;IAAX,IAA8BO;AACpC,QAAMS,uBAAuBT,aAAaC,aAAaT,WAAWC,eAAe7B,KAAD;AAGhF,QAAI,OAAO6C,yBAAyB,UAAU;AAC5C,UAAI;AACF,YAAMC,2BAAwB,MAASD;AAEvC,eAAOC,6BAA6B;MACrC,SAAQC,MAAM;AACb,eAAO;MACR;IACF;AACD,WAAOF;EACR,CAAA;;;AA0Dc,SAAf,WAAmCN,OAAOL,gBAAgB;AACxD,MAAMc,uBAAuBT,MAAMU,aAAaC,QAAQC,IAAKtC,YAAW;AACtE,QAAMuB,eAAeD,gBAAgBtB,QAAQqB,cAAT;AACpCE,iBAAagB,kBAAkBC,KAAKC,IAAL;AAC/B,WAAOzC;EACR,CAJ4B;AAM7B,MAAM0C,wBAAwBhB,MAAMU,aAAa/C,SAASiD,IAAI,MAAhC,WAAA;AAAA,QAAA,OAAA,kBAAsC,WAAOnD,OAAU;AACnF,UAAM;QAAEa;MAAF,IAAab;AAGnB,UAAI,CAACa,QAAQ;AACX,eAAO2C,QAAQC,OAAOzD,KAAf;MACR;AAED,UAAMoC,eAAeD,gBAAgBtB,QAAQqB,cAAT;AAEpC,UAAA,MAAUU,YAAYR,cAAcpC,KAAf,GAAuB;AAC1CoC,qBAAaC,cAAc;AAC3B,YAAM;UAAEP;UAAYC;UAAoBC;QAAlC,IAA8CI;AACpD,YAAMd,QAAQQ,WAAWM,aAAaC,YAAYrC,KAA1B;AAIxBsC,kBAAUC,OAAO1B,MAAR;AAET,YAAI,CAACkB,sBAAsBlB,OAAO6C,WAAWtB,aAAagB,iBAAiB;AACzE,cAAMO,sBAAsBN,KAAKC,IAAL,IAAalB,aAAagB;AACtD,cAAMM,UAAU7C,OAAO6C,UAAUC,sBAAsBrC;AACvD,cAAIoC,WAAW,GAAG;AAChB,mBAAOF,QAAQC,OAAOzD,KAAf;UACR;AACDa,iBAAO6C,UAAUA;QAClB;AAED7C,eAAO+C,mBAAmB,CAAEC,UAASA,IAAX;AAE1B,cAAM7B,QAAQI,aAAaC,YAAYrC,OAAOa,MAAjC;AAEb,eAAO,IAAI2C,QAASM,aAAYC,WAAW,MAAMD,QAAQvB,MAAM1B,MAAD,CAAN,GAAiBS,KAA/B,CAAnC;MACR;AAED,aAAOkC,QAAQC,OAAOzD,KAAf;IACR,CApC6B;AAAA,WAAA,SAAA,KAAA;AAAA,aAAA,KAAA,MAAA,MAAA,SAAA;IAAA;EAAA,EAAA,CAAA;AAsC9B,SAAO;IAAEgD;IAAsBO;EAAxB;AACR;AAGDS,WAAWjE,iBAAiBA;AAC5BiE,WAAWpD,qBAAqBA;AAChCoD,WAAWhD,2BAA2BA;AACtCgD,WAAW/C,oCAAoCA;AAC/C+C,WAAW7C,mBAAmBA;AAC9B6C,WAAWtD,mBAAmBA;",
  "names": ["namespace", "isNetworkError", "error", "CODE_EXCLUDE_LIST", "response", "Boolean", "code", "includes", "isRetryAllowed", "SAFE_HTTP_METHODS", "IDEMPOTENT_HTTP_METHODS", "concat", "isRetryableError", "status", "isSafeRequestError", "config", "indexOf", "method", "isIdempotentRequestError", "isNetworkOrIdempotentRequestError", "noDelay", "exponentialDelay", "retryNumber", "delayFactor", "delay", "Math", "pow", "randomSum", "random", "DEFAULT_OPTIONS", "retries", "retryCondition", "retryDelay", "shouldResetTimeout", "onRetry", "getRequestOptions", "defaultOptions", "getCurrentState", "currentState", "retryCount", "fixConfig", "axios", "defaults", "agent", "httpAgent", "httpsAgent", "shouldRetry", "shouldRetryOrPromise", "shouldRetryPromiseResult", "_err", "requestInterceptorId", "interceptors", "request", "use", "lastRequestTime", "Date", "now", "responseInterceptorId", "Promise", "reject", "timeout", "lastRequestDuration", "transformRequest", "data", "resolve", "setTimeout", "axiosRetry"]
}
